<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Haro Strait Cable Map with Spectrograms</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
  body { margin:0; font-family: Arial, Helvetica, sans-serif; background:#f6f7fb; }
  .header { text-align:center; padding:18px 12px; }
  #map { height: 68vh; width:100%; }
  #spec-box { max-width:1000px; margin:12px auto; text-align:center; }
  #spec-img { max-height:26vh; max-width:100%; border:2px solid #ccc; border-radius:6px; }
  #spec-title { margin-top:8px; font-weight:600; }
  iframe { width:100%; height:380px; border:0; margin-top:14px; }
</style>
</head>
<body>

<div class="header">
  <h2>Spectrogram Viewer</h2>
  <div>Click a channel marker along the cable to view its spectrogram</div>
</div>

<div id="map"></div>

<div id="spec-box">
  <img id="spec-img" src="" alt="Click a channel to show spectrogram">
  <div id="spec-title"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
// ---------- CONFIG ----------
const dx = 3.19;                    // channel spacing (m)
const total_length = 1920;          // total cable length (m)
const loopStarts = [118,147,271,400,466,510,630,1300,1800];
const loopLengths = [30,60,60,30,30,30,30,60,60];

const gps_start = [48.558194, -123.173432];
const gps_bend  = [48.557296, -123.181350];
const gps_end   = [48.547978, -123.183517];

// ---------- helpers ----------
function linspace(a,b,n){ const out=[]; for(let i=0;i<n;i++) out.push(a+(b-a)*(i/(n-1))); return out; }
function deg2rad(d){ return d*Math.PI/180; }
const lat0 = gps_start[0];
const metersPerDegLat = 111320;
const metersPerDegLon = 111320 * Math.cos(deg2rad(lat0));
function latlonToMetersDelta(lat1,lon1,lat2,lon2){
  const dy = (lat2 - lat1) * metersPerDegLat;
  const dx = (lon2 - lon1) * metersPerDegLon;
  return [dx, dy];
}
function metersDeltaToLatLon(latRef, lonRef, dx, dy){
  const lat = latRef + dy / metersPerDegLat;
  const lon = lonRef + dx / metersPerDegLon;
  return [lat, lon];
}

// ---------- Build synthetic model with loops ----------
let xs=[0], ys=[0];
let current_dist=0, main_y=0, loop_dir=1;
for(let idx=0; idx<loopStarts.length; idx++){
  const nextStart=loopStarts[idx], L=loopLengths[idx];
  while(current_dist+dx<nextStart){
    current_dist+=dx; xs.push(current_dist); ys.push(main_y);
  }
  const r=L/(2*Math.PI);
  const nPts=Math.max(8,Math.round(L/dx));
  const thetas=linspace(0,2*Math.PI,nPts);
  for(const th of thetas){
    xs.push(current_dist + r*Math.cos(th));
    ys.push(main_y + loop_dir*r*Math.sin(th));
  }
  current_dist+=L;
  loop_dir*=-1;
}
while(current_dist+dx<=total_length){
  current_dist+=dx; xs.push(current_dist); ys.push(main_y);
}

// Reverse so channel numbers increase R→L
xs = xs.map(v => total_length - v);
xs.reverse(); ys.reverse();
const cumDist = xs.map((v,i)=>i*dx);

// ---------- Map model to GPS preserving loops ----------
const desiredBend = 600;  // m along cable
let ibend = cumDist.findIndex(d=>d>=desiredBend);
if(ibend<0) ibend = Math.floor(xs.length/2);

// compute model bend vector
const [xb,yb] = [xs[ibend]-xs[0], ys[ibend]-ys[0]];
const [gps_dx,gps_dy] = latlonToMetersDelta(gps_start[0], gps_start[1], gps_bend[0], gps_bend[1]);
const magModel = Math.hypot(xb,yb);
const magGps   = Math.hypot(gps_dx,gps_dy);

// basis vectors for mapping
let ux=[1,0], uy=[0,1];
if(magGps>0){
  ux = [gps_dx/magGps, gps_dy/magGps];
  uy = [-ux[1], ux[0]];  // perpendicular
}
const scale = (magModel>0)? (magGps/magModel) : 1;

// optional fine-scale adjust so total matches gps_end roughly
const [gps_dx2,gps_dy2] = latlonToMetersDelta(gps_start[0], gps_start[1], gps_end[0], gps_end[1]);
const totalGpsLen = Math.hypot(gps_dx2,gps_dy2);
const scaleAdj = totalGpsLen / total_length;
const totalScale = scale * scaleAdj;

// map all model points preserving loops
const cableLatLon = xs.map((xm,i)=>{
  const ym = ys[i];
  const east = (xm - xs[0])*totalScale*ux[0] + ym*totalScale*uy[0];
  const north= (xm - xs[0])*totalScale*ux[1] + ym*totalScale*uy[1];
  return metersDeltaToLatLon(gps_start[0], gps_start[1], east, north);
});

// ---------- Map ----------
const map = L.map('map').setView(gps_start, 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:18}).addTo(map);
const cableLine = L.polyline(cableLatLon, {color:'blue', weight:3}).addTo(map);
map.fitBounds(cableLine.getBounds());

// ---------- Channel markers + spectrograms ----------
let channelMarkers=[];
fetch('spectrogram_index.txt')
 .then(r=>r.text())
 .then(t=>{
   const specs=t.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
   for(let i=0;i<cableLatLon.length;i++){
     const latlng=cableLatLon[i];
     const color=(i===25)?'red':'blue';
     const m=L.circleMarker(latlng,{radius:3,color,fill:true,fillOpacity:0.9}).addTo(map);
     const idx=Math.min(Math.round((i/(cableLatLon.length-1))*(specs.length-1)),specs.length-1);
     const chosen=specs[idx];
     m.on('click',()=>{
       document.getElementById('spec-img').src=chosen;
       document.getElementById('spec-title').textContent=`Channel ${i} — ${(cumDist[i]).toFixed(2)} m`;
     });
     channelMarkers.push(m);
   }
 });

// ---------- Overlay Pintail boat track ----------
fetch('pintail_boat_track.html')
 .then(r=>r.text())
 .then(txt=>{
   const matches=txt.match(/\[\s*-?\d+\.\d+,\s*-?\d+\.\d+\s*\]/g);
   if(matches&&matches.length){
     const coords=matches.map(s=>s.replace(/\[|\]/g,'').split(',').map(Number));
     L.polyline(coords,{color:'green',weight:3,opacity:0.7}).addTo(map);
   }
 });

// ---------- Embed waypoints ----------
const iframe=document.createElement('iframe');
iframe.src='pintail_waypoints_track.html';
iframe.style.width='100%';
iframe.style.height='360px';
iframe.style.border='none';
iframe.style.marginTop='12px';
document.body.appendChild(iframe);
</script>
</body>
</html>
